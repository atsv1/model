package mp.parser;

/**
 * User: atsv
 * Date: 04.04.2006
 */
public class ScriptLanguageDef {

  /** массив, в котором перечислены все возможные операции, определяемые языком.
   *Для добавления новой операции необходимо выполнить следующие действия:
   * 1. Добавить символ, который будет соответствовать операции в данный масив;
   * 2. Добавить в требуемое место массива operationPriority (приоритет операции)
   *    символ добавляемой операции;
   * 3. Создать класс, который будет отвечать за выполнение данной операции. Класс
   *    должен быть наследником ScriptOperation
   * 4. Запрограммировать класс для выполнения нужной операции
   * 5. Прописать в процедуре ScriptActionLexem3Operand.GetExecutableObject
   *    создание нового класса
   * 6. Также нужно прописать символ операции в массиве ScriptLexemTokenizer.LexemSeparatorList
  */
  public static final String[] SimpleOperation3OperandList =
          {"+","-","/","*","xor", "and", "or", "=", ":=", "^", "<>", "<", ">", ">=", "<="};

  public static final String[] SimpleOperation2OperandList =
          {"not"};


  public static final
  String[] LanguageDef =
   {
    "Начало -> (#Операнд#Функция#Число#Конец#if# jnt#;#while#var#",
    "( -> (#Операнд#Функция#Действие3#Действие2# Число#ПараметрФункции#",
    "Операнд -> Действие3#Действие2#)#Конец#;# then #, # else#[#]#",
    "Действие3 -> Действие2# Операнд#Число#(#Процедура#Функция#;#",
    "Действие2 -> Действие3# Операнд# Число#(#Процедура#Функция#;#",
    "Число -> Действие3#Действие2# (#)#Конец#;# end# else# then#, # ]# ",
    ") -> )#Действие3# Действие2# Конец#if#;#then# Адрес# do# else# ",
    "Функция -> (#Действие3# Действие2# Конец#;#)#",
    "; -> Операнд# Число# Функция# ;# Конец# if#end# Ссылка# jnt# jmp# Метка# begin# while# ",
    "if -> (# Операнд# Число#",
    "then -> begin# Операнд# if# Функция#",
    "begin -> if# операнд# функция# ;# jnt# jmp#var#",
    "end -> else# ;#конец# Метка# end#",
    "else -> Операнд# begin# ;# Функция# if#  ",
    "jnt -> (# Операнд# Число# Функция# ",
    "jmp -> Адрес#",
    "Метка -> ;#Операнд# Функция#Конец# end# begin#",
    "Адрес -> begin# Операнд# Число# Функция# if# ;# ",
    "while -> Операнд# Функция# (# ",
    "do -> begin# Операнд# Функция# if# while#",
    ", -> Операнд# Число# (# Функция#",
    "ПараметрФункции -> Число#,#)#операнд# ]#[#",
    "[ -> Операнд# Число# Функция# ПараметрФункции#",
    "] -> ;#)#Действие2# Действие3# ]#,# ",
    "var -> Операнд#"
   };

  protected final static String CREATE_LEXEM_PREFIX = "New_";

 /** Массив, определяющий свертку.
  *В нулевом столбце массива хранится наименование объекта, в который будет
  * свернута конструкция в строке лексем - т.е. наименование лексемы, которая
  * останется в строке лексем вместо всех лексем, удаленных из строки лексем
  * после свертки. То есть, из списка лексем просто удалятся ВСЕ лексемы, кроме той, название которой
  * указано в нулевом стобце массива.
  * Если нулевой столбец пуст, то после свертки ни одной из свернутых лексем в свертке не остается
  *
  * Во первом столбце будет наименование лексемы, которая укажет на лексему
  * в свертке, у которой нужно вызвать функцию, которая возвращает объект, который
  * будет вставлен в программу первым. Обычно это объект - операция (умножение,
  * деление и пр.)
  *
  * Далее в массиве по порядку следования будут идти  сворачиваемые лексемы
  *
  */
  public static final String[][] productionList =
     {
       {"",         "Действие3", "Операнд","Действие3","Операнд"},//0
       {"",         "Действие3", "Операнд","Действие3","Число"},  //1
       {"",         "Действие3", "Число","Действие3","Операнд"},  //2
       {"",         "Действие3", "Число","Действие3","Число"},    //3
       {"",         "",         "(", ")"},                      //4
       {"Операнд",  "",         "(", "Операнд",")"},            //5
       {"Число",    "",         "(", "Число",")"},              //6
       {"",         "",         "Начало", "Конец"},             //7
       {"",         "",         "Начало", "Операнд", "Конец"},  //8
       {"",         "Функция",  "Функция", "(", "Операнд", ")"},//9
       {"",         "Функция",  "Функция","(", "Число", ")"},   //10
       {"",         "Функция",  "Функция", "(", "Операнд", ")"},//11
       {"",         "Функция",  "Функция", "(", ")"},           //12
       {"Начало",   "",         "Начало", ";"},                 //13
       {"",  "Действие2", "Действие2", "Операнд"},       //14
       {"",  "Действие2", "Действие2", "Число"},         //15
       {"",         "if",        "if","Число", "then"},         //16
       {"",         "if",        "if", "Операнд","then"},       //17
       {"",         "jmp",       "jmp","Адрес"},                //18
       {"",         "jnt",       "jnt", "Операнд",    "Адрес" }, //19
       {"",         "jnt",       "jnt", "Число",    "Адрес" }, //20
       {"",         "Метка",          "Метка"},                //21
       {CREATE_LEXEM_PREFIX + "ПараметрФункции",         "",           "Операнд", ","}, //22
       {CREATE_LEXEM_PREFIX + "ПараметрФункции",         "",           "Число", ","}, //23
       {CREATE_LEXEM_PREFIX + "ПараметрФункции",         "",           "ПараметрФункции", "Операнд"},//24
       {CREATE_LEXEM_PREFIX + "ПараметрФункции",         "",           "ПараметрФункции", "Число"}, //25
       {"ПараметрФункции",         "",           "ПараметрФункции", ","}, //26
       {"",         "Функция",  "Функция", "(", "ПараметрФункции", ")"},//27
       {"",         "[", "Операнд", "[", "Число", "]"}, //28
       {"",         "[", "Операнд", "[", "ПараметрФункции", "]"}, //29
       {"",         "[", "Операнд", "[", "Операнд", "]"}, //30
       {"",         "var", "Операнд", ":", "integer", ";"}, //31
     };

  public static final String[][] operationPriority =
          { {"Функция"},
            {"("},
            {"["},
            {"^"},
            {"*","/"},
            {"+","-"},
            //{"and", "xor", "not"},
            { "=", "<=", ">=", "<>", "<", ">"},
             {"and", "xor", "not", "or"},
            {":="}
          };


  /** Массив с перечнем функций, вызов которых доступен из парсера
   * В нулевом столбце хранится наименование функции
   * В первом столбце - уникальный идентификатор функции
   * В оставшихся столбцах хранятся типы переменных.
   * В последнем столбце хранится тип результата
   *
   * Для того, чтобы добавить новую функцию, необходимо выполнить следующие
   * действия:
   * 1. Добавить строку в данный массив
   * 2. Добавить новую функция в класс ScriptOperationFunction, которая выполняла
   * бы данную функцию
   * 3. Вставить вызов данной функции в процедуре
   * ScriptOperationFunction.ExecOperation в соответствующую секцию оператора switch
   */
  public static final String[][] FunctionsList =
    {
      {"sin",                "0", "real/integer", "real"},
      {"cos",                "1", "integer/real", "real"},
      {"tan",                "2",  "integer/real", "real"},
      {"pi",                 "3","real"},
      {"exponent",           "4","real"},
      {"log",                "5", "integer/real", "real"},
      {"exp",                "6", "integer/real", "real"},
      {"sqrt",               "7", "integer/real", "real"},
      {"abs",                "8", "integer/real", "real"},
      {"rnd",                "9",   "real"},
      {"truncate",           "10", "integer",  "real"},
      {"asin",               "11", "real",     "real"},
      {"sqr",                "12", "real",     "real"},
      {"StopExecution",      "13", "string",   "boolean"},
      {"StartModel",         "14", "string",   "boolean"},
      {"SetToInitCondition", "15", "string",   "boolean"},
      {"Send",               "16", "",         "boolean"},
      {"Get",                "17", "",         "real"},
      {"string",             "18", "integer/real",       "string"},
      {"integer",            "19", "",         "integer"},
      {"real",               "20", "",         "real"},
      {"mod",                "21", "integer","integer"},
      {"ReLinkParam",        "22", "",         "boolean"},
      {"print",              "100", "integer/real/string/boolean", "boolean"},

       //функции, связанные с матрицами
      {"GetArrayValue",           "200", "", "integer" },
      {"SetArrayValue",           "201", "", "integer" },
      {"GetArraySumm",            "202", "", "integer"},
      {"GetArrayMinValue",        "203", "", "integer"},
      {"GetArrayMaxValue",        "204", "", "integer"},
      {"GetArrayDimension",       "205", "", "integer"},
      {"GetArrayDimensionLength", "206", "integer", "integer"},
      {"ArrayTranspose",          "207", "", "integer"},
      {"ArrayMul",                "208", "", "integer"},
      {"ArrayInverse",            "209", "", "integer"},
      {"ShiftR",                  "210", "integer", "integer"},
      {"ShiftL",                  "211", "integer", "integer"},
      //функции, связанные с получение значений различных распределений
      {"Distribution_Normal",     "300", "",  "real"},
      {"Distribution_Normal2",     "301", "",  "real"},

      // Функции переходов
      {"Exit", "400", "", "integer"}
    };

  /**Массив, описывающий автомат переходов состояний при разборе условных
   * операторов.
   * В нулевом столбце - уникальный идентификатор состояния
   * В первом столбце - лексемы перехода (список лексем через запятую), т.е. лексемы, поступление которых ожидается
   * Во втором столбце - ссылка на состояние, в которое должен перейти автомат
   * В третьем столбце - количество лексем до лексемы, по которой будет
   * осуществлен переход в другое состояние (-1 - любое количество лексем,
   * 0 - переход осуществляется сразу же, 1 - следующая же лексема
   * должна быть лексемой перехода)
   */
  public static final String[][] Automat =
          {
            {"1",  "if",      "2",  "-1"},//начальное состояние
            {"1",  "while",   "16", "-1" },
            {"2",  "then",    "3",  "-1"},//ожидание THEN
            {"3",  "begin",   "4",   "1"},// после then должно идти либо begin
            {"3",  "операнд, функция",   "5",   "1"}, // либо какая-либо операция
            {"3",  "if",      "2", "1"},//либо снова IF
            {"3",  "while",   "16", "-1"},// после if (XXX) then  может следовать и while
            {"4",  "end",     "7",    "-1"},//ожидание end после if XXX begin XXX
            {"4",  "if",      "2",    "-1"},//либо снова переходим в IF
            {"4",  "while",   "16",    "-1"},//либо снова переходим WHILE
            {"5",  ";",       "6",   "-1"},//ожидание ";" после THEN
            {"5",  "else",    "15",     "-1"},//либо после THEN  и какой-то операции последует ELSE
            {"6",  "",        "1",   "0"},//сразу переходим в начальное состояние
            {"7",  ";",       "13",   "1"},// ожидаем ; после IF XXX then BEGIN XXX END
            {"7",  "else",    "8",   "1" },
            {"7",  "Конец",   "22",  "1" },
            {"8",  "begin",   "10",  "1"},//ожидание begin после else
            {"8",  "операнд, функция", "9", "1"},
            {"8",  "if",       "2",    "1"},
            {"9",  ";",       "11",    "-1"},
            {"10", "end",     "12",    "-1" },//ожидание end после else begin
            {"10", "if",      "2",     "-1" },
            {"11", "",        "1",     "0"},
            {"12", ";",       "14",    "1"},//ожидание ";" после "else begin end"
            {"12", "Конец",   "23",    "1"},// не дождались ; после END
            {"13", "",        "1",     "0"},// получили ";" после "if XXX then begin XXX end"
            {"14", "",        "1",     "0"},
            {"15", "begin",   "10",    "1" },//
            {"15", "операнд, функция", "9", "1"},
            {"22", "",        "1",     "0"},
            {"23", "",        "1",     "0"},
            // цикл WHILE
            {"16", "do",      "17",    "-1"}, //получили while
            {"17", "begin",   "18",    "1"},  // получили while do
            {"17", "операнд, функция", "19",  "1"}, // получили while do
            {"17", "if",      "2",     "1"},
            {"17", "while",   "16",    "1"},
            {"17",  ";",      "1",     "-1"},
            {"18", "end",     "20",    "-1"},// получили while do begin XXXXX теперь ожидаем end
            {"18", "if",      "2",     "-1"},
            {"18", "while",   "16",    "-1"},
            {"19", ";",       "21",    "-1"},
            {"19", "while",   "16",    "1" },
            {"19", "if",      "2",     "1"},
            {"20", "",        "1",     "0"},
            {"21", "",        "1",     "0"},
          };

  public static  String GetTempVarPrefix(){
    return "TmpVar_";
  }

  public static  boolean IsNamePrefix( String aName ){
    return aName.startsWith(GetTempVarPrefix());
  }

  public static String VAR_NAME_ADDRESS = "Адрес";
  public static String VAR_NAME_LABEL = "Метка";

  public static  boolean IsServiceName(String aName){
    if ( aName == null || "".equalsIgnoreCase( aName ) ){
      return false;
    }
    if ( IsNamePrefix(aName) ) {
      return true;
    }
    if ( aName.equalsIgnoreCase( VAR_NAME_ADDRESS ) || aName.equalsIgnoreCase(VAR_NAME_LABEL) ){
      return true;
    }
    return false;
  }

  public static int GetArrayGetFunction(){
  	int i = 0;
  	while ( i < FunctionsList.length ) {
  		if ( "GetArrayValue".equals( FunctionsList[i][0] ) ) {
  			return i;
  		}
  		i++;
  	}
  	return -1;
  }

  public static int GetArraySetFunction(){
  	int i = 0;
  	while ( i < FunctionsList.length ) {
  		if ( "SetArrayValue".equals( FunctionsList[i][0] ) ) {
  			return i;
  		}
  		i++;
  	}
  	return -1;
  }

}

